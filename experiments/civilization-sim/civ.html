<!DOCTYPE html>
<html>
<head>
  <title>Hierarchical Modular Network</title>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/p5.js/1.4.0/p5.js"></script>
  <style>
    body, html {
      margin: 0;
      padding: 0;
      width: 100%;
      height: 100%;
      overflow: hidden;
    }
    canvas {
      width: 100% !important;
      height: 100% !important;
    }
  </style>
</head>
<body>
  <script>
    // Network parameters
    const MIN_CLUSTERS = 2;
    const MAX_CLUSTERS = 6;
    const MEAN_CLUSTERS = 4;
    const CLUSTER_STD_DEV = 1;
    const NODES_PER_CLUSTER = 8;
    const BASE_INTRA_CLUSTER_DENSITY = 0.9;
    const BASE_INTER_CLUSTER_DENSITY = 0.3;
    const BASE_INTER_SUPER_DENSITY = 0.1;
    const TRAIT_SIMILARITY_WEIGHT = 0.3;
    const TRAIT_CLUSTERING_STRENGTH = 1.2;

    // Add gaussian random function
    function gaussianRandom(mean, stdDev) {
      let u = 0, v = 0;
      while(u === 0) u = random(); // Converting [0,1) to (0,1)
      while(v === 0) v = random();
      const num = Math.sqrt(-2.0 * Math.log(u)) * Math.cos(2.0 * Math.PI * v);
      return num * stdDev + mean;
    }

    // Population cycle parameters
    let INITIAL_POPULATION = 0; // Will be calculated after cluster generation
    const POPULATION_CYCLE_DURATION = 3000;
    const GROWTH_PHASE_DURATION = 2000;
    const COLLAPSE_PHASE_DURATION = 1000;
    const MAX_POPULATION_MULTIPLIER = 1.5;
    const MIN_POPULATION_MULTIPLIER = 0.5;
    let populationCycleStartFrame = 0;
    let isInGrowthPhase = true;

    // Visual parameters
    const NODE_SIZE = 10;
    const MIN_NODE_DISTANCE = 40; // Added minimum distance between nodes
    const BASE_CYCLE_DURATION = 60000;
    const BASE_SUBCYCLE_DURATION = 20000;
    let currentCycleDuration = BASE_CYCLE_DURATION;
    let currentSubcycleDuration = BASE_SUBCYCLE_DURATION;
    const CYCLE_VARIATION = 0.2;

    // Spatial partitioning parameters
    const GRID_CELL_SIZE = 150;
    const LOCAL_RADIUS = 200;
    const GLOBAL_RADIUS = 500;
    const GLOBAL_CHECK_FREQUENCY = 0.1;
    let spatialGrid = [];
    let gridWidth = 0;
    let gridHeight = 0;
    
    // Network data structures
    let nodes = [];
    let edges = [];
    let edgeMap = new Map();
    let startTime;
    let dynamicEdges = new Set();
    let startupPhase = 1.0;
    let globalInteractionTimer = 0;

    const INITIAL_CLUSTERS = 8; // Start with many small clusters
    let clusters = []; // Array of cluster objects

    class Cluster {
      constructor(id) {
        this.id = id;
        this.nodes = new Set();
        this.traits = {
          efficiency: 0,
          adaptability: 0,
          cooperation: 0,
          aggression: 0,
          innovation: 0,
          resilience: 0
        };
        this.position = createVector();
        this.color = color(random(255), random(255), random(255));
        
        // Cluster specialization
        this.specialization = {
          production: random(0.3, 0.7),
          storage: random(0.3, 0.7),
          distribution: random(0.3, 0.7),
          research: random(0.3, 0.7)
        };
        
        // Cluster behavior and state
        this.dominantBehavior = 'generalist';
        this.phase = 'stable';
        this.stability = random(0.7, 1.0);
        this.cohesion = random(0.6, 0.9);
        this.influence = random(0.4, 0.8);
        
        // Resource management
        this.sharedResources = 0;
        this.resourceCapacity = random(5, 10);
        this.resourceDistributionEfficiency = random(0.7, 0.9);
        
        // Inter-cluster relationships
        this.allies = new Set();
        this.rivals = new Set();
        this.tradePartners = new Map(); // Maps cluster IDs to trade strength
        
        // Cultural memory
        this.culturalTraits = new Map();
        this.innovationHistory = [];
        this.age = 0;
      }
      
      updateTraits() {
        // Reset traits
        for (let trait in this.traits) {
          this.traits[trait] = 0;
        }
        
        // Calculate average traits from member nodes
        let totalNodes = this.nodes.size;
        if (totalNodes === 0) return;
        
        this.nodes.forEach(nodeId => {
          const node = nodes.find(n => n.id === nodeId);
          if (node) {
            for (let trait in this.traits) {
              this.traits[trait] += node.traits[trait];
            }
          }
        });
        
        // Average the traits
        for (let trait in this.traits) {
          this.traits[trait] /= totalNodes;
        }
        
        // Update specialization based on traits
        this.updateSpecialization();
      }
      
      updateSpecialization() {
        // Update specializations based on traits and current state
        this.specialization.production = lerp(
          this.specialization.production,
          (this.traits.efficiency * 0.6 + this.traits.cooperation * 0.4),
          0.1
        );
        
        this.specialization.storage = lerp(
          this.specialization.storage,
          (this.traits.resilience * 0.5 + this.traits.efficiency * 0.5),
          0.1
        );
        
        this.specialization.distribution = lerp(
          this.specialization.distribution,
          (this.traits.cooperation * 0.7 + this.traits.adaptability * 0.3),
          0.1
        );
        
        this.specialization.research = lerp(
          this.specialization.research,
          (this.traits.innovation * 0.8 + this.traits.adaptability * 0.2),
          0.1
        );
        
        // Determine dominant behavior
        const specs = Object.entries(this.specialization);
        specs.sort((a, b) => b[1] - a[1]);
        
        if (specs[0][1] > specs[1][1] * 1.5) {
          this.dominantBehavior = specs[0][0];
        } else {
          this.dominantBehavior = 'generalist';
        }
      }
      
      updateState() {
        this.age++;
        
        // Update stability based on member cohesion
        let totalCohesion = 0;
        let connections = 0;
        
        this.nodes.forEach(nodeId => {
          const node = nodes.find(n => n.id === nodeId);
          if (node) {
            this.nodes.forEach(otherId => {
              if (nodeId !== otherId) {
                const other = nodes.find(n => n.id === otherId);
                if (other) {
                  const memory = node.socialMemory.get(otherId);
                  if (memory) {
                    totalCohesion += memory.strength;
                    connections++;
                  }
                }
              }
            });
          }
        });
        
        if (connections > 0) {
          this.cohesion = lerp(this.cohesion, totalCohesion / connections, 0.1);
        }
        
        // Update phase based on stability and cohesion
        if (this.cohesion < 0.3) {
          this.phase = 'fragmenting';
        } else if (this.stability < 0.4) {
          this.phase = 'unstable';
        } else if (this.cohesion > 0.8 && this.stability > 0.8) {
          this.phase = 'flourishing';
        } else {
          this.phase = 'stable';
        }
        
        // Resource management
        this.sharedResources *= 0.99; // Natural decay
        this.nodes.forEach(nodeId => {
          const node = nodes.find(n => n.id === nodeId);
          if (node) {
            // Contribute to shared resources
            const contribution = node.resources * 0.1 * this.traits.cooperation;
            node.resources -= contribution;
            this.sharedResources += contribution * this.resourceDistributionEfficiency;
          }
        });
        
        // Distribute resources if needed
        if (this.sharedResources > this.resourceCapacity * 0.8) {
          this.distributeResources();
        }
      }
      
      distributeResources() {
        const resourcesPerNode = (this.sharedResources * 0.5) / this.nodes.size;
        this.nodes.forEach(nodeId => {
          const node = nodes.find(n => n.id === nodeId);
          if (node) {
            node.resources += resourcesPerNode * this.resourceDistributionEfficiency;
          }
        });
        this.sharedResources *= 0.5;
      }
      
      shouldSplit() {
        return this.phase === 'fragmenting' && this.nodes.size > 5;
      }
      
      canMerge(other) {
        if (!other) return false;
        
        const traitCompatibility = Object.keys(this.traits).reduce((sum, trait) => {
          return sum + Math.abs(this.traits[trait] - other.traits[trait]);
        }, 0) / Object.keys(this.traits).length;
        
        return this.phase === 'stable' && 
               other.phase === 'stable' && 
               traitCompatibility < 0.3 &&
               this.cohesion > 0.6 && 
               other.cohesion > 0.6;
      }
    }

    // Helper function to get grid cell indices
    function getGridIndices(x, y) {
      return {
        x: Math.floor(x / GRID_CELL_SIZE),
        y: Math.floor(y / GRID_CELL_SIZE)
      };
    }

    // Update spatial grid
    function updateSpatialGrid() {
      // Calculate grid dimensions
      gridWidth = Math.ceil(width / GRID_CELL_SIZE);
      gridHeight = Math.ceil(height / GRID_CELL_SIZE);
      
      // Reset grid with pre-allocated arrays
      spatialGrid = new Array(gridWidth);
      for (let x = 0; x < gridWidth; x++) {
        spatialGrid[x] = new Array(gridHeight);
        for (let y = 0; y < gridHeight; y++) {
          spatialGrid[x][y] = [];
        }
      }
      
      // Add nodes to grid
      for (let node of nodes) {
        const indices = getGridIndices(node.x, node.y);
        if (indices.x >= 0 && indices.x < gridWidth && 
            indices.y >= 0 && indices.y < gridHeight) {
          spatialGrid[indices.x][indices.y].push(node);
        }
      }
    }

    // Get nearby nodes using optimized grid lookup
    function getNearbyNodes(node, radius, includeGlobal = false) {
      const nearby = new Set();
      const indices = getGridIndices(node.x, node.y);
      const gridRadius = Math.ceil(radius / GRID_CELL_SIZE);
      
      // Check cells within radius
      for (let dx = -gridRadius; dx <= gridRadius; dx++) {
        for (let dy = -gridRadius; dy <= gridRadius; dy++) {
          const gx = indices.x + dx;
          const gy = indices.y + dy;
          
          if (gx >= 0 && gx < gridWidth && gy >= 0 && gy < gridHeight) {
            const cell = spatialGrid[gx][gy];
            for (let other of cell) {
              if (other !== node) {
                const dx = other.x - node.x;
                const dy = other.y - node.y;
                const distSq = dx * dx + dy * dy;
                if (distSq <= radius * radius) {
                  nearby.add(other);
                }
              }
            }
          }
        }
      }

      // Occasionally include some random global interactions
      if (includeGlobal && random() < GLOBAL_CHECK_FREQUENCY) {
        const numGlobalChecks = min(5, nodes.length - nearby.size);
        const remainingNodes = nodes.filter(n => n !== node && !nearby.has(n));
        for (let i = 0; i < numGlobalChecks; i++) {
          if (remainingNodes.length > 0) {
            const randomIndex = floor(random(remainingNodes.length));
            nearby.add(remainingNodes[randomIndex]);
            remainingNodes.splice(randomIndex, 1);
          }
        }
      }

      return nearby;
    }

    function getPopulationTarget() {
      const cycleProgress = (frameCount - populationCycleStartFrame) % POPULATION_CYCLE_DURATION;
      const isGrowth = cycleProgress < GROWTH_PHASE_DURATION;
      
      if (isGrowth !== isInGrowthPhase) {
        isInGrowthPhase = isGrowth;
        // Reset reproduction cooldowns when phase changes to allow faster adaptation
        for (let node of nodes) {
          node.lastReproduction = 0;
        }
      }

      if (isGrowth) {
        // During growth phase: smooth curve from min to max
        const growthProgress = cycleProgress / GROWTH_PHASE_DURATION;
        return INITIAL_POPULATION * lerp(MIN_POPULATION_MULTIPLIER, MAX_POPULATION_MULTIPLIER, growthProgress);
      } else {
        // During collapse phase: smooth curve from max to min
        const collapseProgress = (cycleProgress - GROWTH_PHASE_DURATION) / COLLAPSE_PHASE_DURATION;
        return INITIAL_POPULATION * lerp(MAX_POPULATION_MULTIPLIER, MIN_POPULATION_MULTIPLIER, collapseProgress);
      }
    }

    function updatePopulationPressure() {
      const target = getPopulationTarget();
      const currentPop = nodes.length;
      
      for (let node of nodes) {
        if (currentPop > target) {
          const overpopulation = (currentPop - target) / target;
          node.lifespan *= (1 - overpopulation * 0.1);
          node.reproductiveEnergy = 0.7 + overpopulation * 0.2;
          node.resources *= (1 - overpopulation * 0.01);
        } else {
          const underpopulation = (target - currentPop) / target;
          node.lifespan *= (1 + underpopulation * 0.1);
          node.reproductiveEnergy = max(0.4, 0.7 - underpopulation * 0.3);
          node.resources *= (1 + underpopulation * 0.01);
        }
      }
    }

    function getTraitSimilarity(node1, node2) {
      let similarity = 0;
      let totalTraits = 0;
      
      for (let trait in node1.traits) {
        similarity += 1 - Math.abs(node1.traits[trait] - node2.traits[trait]) / 0.4;
        totalTraits++;
      }
      
      return similarity / totalTraits;
    }

    class Node {
      constructor(id, cluster, supercluster) {
        this.id = id;
        this.cluster = cluster;
        this.supercluster = supercluster;
        this.x = 0;
        this.y = 0;
        this.vx = 0;
        this.vy = 0;
        this.targetX = random(width);
        this.targetY = random(height);
        this.energy = random(0, 1);
        this.state = random(['active', 'dormant', 'transitioning']);
        
        // Enhanced memory system
        this.socialMemory = new Map(); // Store interaction history with other nodes
        this.traitMemory = []; // Remember past trait values
        this.behaviorPatterns = {
          cooperative: random(0.3, 0.7),
          competitive: random(0.3, 0.7),
          innovative: random(0.3, 0.7)
        };
        
        // Resource management
        this.resourceBuffer = [];
        this.resourceDemand = random(0.3, 0.7);
        this.resourceSurplus = 0;
        this.resourceDeficit = 0;
        
        // Social network properties
        this.connectionStrengths = new Map();
        this.preferredPartners = new Set();
        this.rivalries = new Set();
        this.influence = random(0.3, 0.7);
        
        this.age = 0;
        this.generation = 0;
        
        // Normal distribution with mean=3, stdDev=1, clamped to range [1,5]
        this.maxConnections = constrain(round(gaussianRandom(3, 1)), 1, 5);
        this.currentConnections = 0;
        this.magneticPolarity = random([-1, 1]); // -1 repels, 1 attracts
        this.magneticStrength = random(0.5, 2.0);
        this.personalSpace = random(30, 100);
        this.socialRange = random(100, 300);
        
        this.baseLifespan = random(500, 1500);
        this.lifespan = this.baseLifespan;
        this.reproductiveEnergy = 0.7;
        this.traits = {
          efficiency: random(0.8, 1.2),
          adaptability: random(0.8, 1.2),
          cooperation: random(0.8, 1.2),
          aggression: random(0.8, 1.2),
          innovation: random(0.8, 1.2), // New trait
          resilience: random(0.8, 1.2)  // New trait
        };
        this.resources = random(0.3, 0.7);
        this.lastReproduction = 0;
        this.reproductiveCooldown = 200;
        
        // Behavioral state
        this.mood = random(0, 1);
        this.stress = 0;
        this.adaptationRate = random(0.05, 0.15);
      }

      updateBehavior() {
        // Update mood based on resources and connections
        this.mood = lerp(this.mood, 
          (this.energy * 0.3 + this.resources * 0.3 + 
           (this.currentConnections / this.maxConnections) * 0.4),
          0.1
        );
        
        // Update stress based on environmental factors
        const resourceStress = 1 - this.resources;
        const socialStress = max(0, (this.currentConnections - this.maxConnections) / this.maxConnections);
        const environmentalStress = (sin(frameCount / 1000) + 1) / 2;
        
        this.stress = lerp(this.stress,
          (resourceStress * 0.4 + socialStress * 0.3 + environmentalStress * 0.3),
          this.adaptationRate
        );
        
        // Adapt behavior patterns based on success
        if (frameCount % 100 === 0) {
          const successRate = this.getSuccessRate();
          this.behaviorPatterns.cooperative = lerp(
            this.behaviorPatterns.cooperative,
            successRate > 0.5 ? this.traits.cooperation : 1 - this.traits.cooperation,
            this.adaptationRate
          );
          
          this.behaviorPatterns.competitive = lerp(
            this.behaviorPatterns.competitive,
            this.stress > 0.7 ? this.traits.aggression : 1 - this.traits.aggression,
            this.adaptationRate
          );
        }
      }

      getSuccessRate() {
        let successCount = 0;
        let totalInteractions = 0;
        
        this.socialMemory.forEach((memory, partnerId) => {
          successCount += memory.successfulInteractions;
          totalInteractions += memory.successfulInteractions + memory.failedInteractions;
        });
        
        return totalInteractions > 0 ? successCount / totalInteractions : 0.5;
      }

      // Enhanced reproduction method
      reproduce() {
        const currentPop = nodes.length;
        const target = getPopulationTarget();
        
        if (this.energy < this.reproductiveEnergy || 
            frameCount - this.lastReproduction < this.reproductiveCooldown) {
          return null;
        }

        const popRatio = currentPop / target;
        if (random() > 1.5 - popRatio) {
          return null;
        }

        const offspring = new Node(nodes.length, this.cluster, this.supercluster);
        offspring.x = this.x + random(-20, 20);
        offspring.y = this.y + random(-20, 20);
        offspring.generation = this.generation + 1;
        
        // Inherit traits with mutation and innovation
        for (let trait in this.traits) {
          const mutationRate = this.traits.innovation * 0.2;
          const mutation = random(-mutationRate, mutationRate);
          offspring.traits[trait] = constrain(
            this.traits[trait] * (1 + mutation),
            0.5,
            1.5
          );
        }
        
        // Inherit some behavioral patterns
        offspring.behaviorPatterns = {
          cooperative: lerp(this.behaviorPatterns.cooperative, random(0.3, 0.7), 0.3),
          competitive: lerp(this.behaviorPatterns.competitive, random(0.3, 0.7), 0.3),
          innovative: lerp(this.behaviorPatterns.innovative, random(0.3, 0.7), 0.3)
        };
        
        // Split energy and resources
        const splitRatio = 0.6;
        this.energy *= splitRatio;
        offspring.energy = this.energy;
        this.resources *= splitRatio;
        offspring.resources = this.resources;
        
        // Transfer some social memory
        this.socialMemory.forEach((memory, partnerId) => {
          if (random() < 0.3) { // 30% chance to inherit each relationship memory
            offspring.socialMemory.set(partnerId, {
              ...memory,
              strength: memory.strength * 0.5 // Weaker inherited relationships
            });
          }
        });
        
        this.lastReproduction = frameCount;
        return offspring;
      }

      // Add to memory system
      updateSocialMemory(partner, success) {
        if (!this.socialMemory.has(partner.id)) {
          this.socialMemory.set(partner.id, {
            successfulInteractions: 0,
            failedInteractions: 0,
            lastInteraction: frameCount,
            strength: 0.5
          });
        }
        
        const memory = this.socialMemory.get(partner.id);
        if (success) {
          memory.successfulInteractions++;
        } else {
          memory.failedInteractions++;
        }
        
        memory.lastInteraction = frameCount;
        memory.strength = lerp(memory.strength, 
          success ? 1 : 0,
          0.1
        );
        
        // Update preferred partners list
        if (memory.strength > 0.7) {
          this.preferredPartners.add(partner.id);
        } else if (memory.strength < 0.3) {
          this.preferredPartners.delete(partner.id);
          this.rivalries.add(partner.id);
        }
      }
    }

    class Edge {
      constructor(source, target, type) {
        this.source = source;
        this.target = target;
        this.type = type;
        this.strength = 1;
        this.age = 0;
        this.birth = millis();
        this.shouldGlow = random() < 0.05;
        this.shouldRender = type === 'intra' || random() < 0.2;
        this.id = `${Math.min(source.id, target.id)}-${Math.max(source.id, target.id)}`;
        
        // New properties for resource flow
        this.resourceFlow = 0;
        this.resourceCapacity = random(0.1, 0.3);
        this.flowEfficiency = random(0.8, 1.2);
        
        // Relationship memory
        this.successfulInteractions = 0;
        this.failedInteractions = 0;
        this.trust = 0.5;
        this.lastInteraction = millis();
        
        // Dynamic properties
        this.stability = random(0.7, 1.0);
        this.adaptability = random(0.8, 1.2);
      }

      getColor() {
        const baseColor = this.type === 'intra' ? 
          color(170, 170, 190, 180) :
          this.type === 'inter' ?
          color(190, 170, 170, 180) :
          color(170, 190, 170, 180);
        
        // Modify color based on trust and resource flow
        const trustColor = lerpColor(
          color(190, 170, 170, 180),
          color(170, 190, 170, 180),
          this.trust
        );
        
        // Flow intensity affects brightness
        const flowIntensity = abs(this.resourceFlow) / this.resourceCapacity;
        const finalColor = lerpColor(
          baseColor,
          trustColor,
          constrain(flowIntensity * 2, 0, 1)
        );
        
        return finalColor;
      }
      
      updateRelationship() {
        // Age-based trust decay
        const timeSinceLastInteraction = (millis() - this.lastInteraction) / 1000;
        this.trust *= pow(0.999, timeSinceLastInteraction);
        
        // Success/failure ratio affects trust
        const totalInteractions = this.successfulInteractions + this.failedInteractions;
        if (totalInteractions > 0) {
          const successRatio = this.successfulInteractions / totalInteractions;
          this.trust = lerp(this.trust, successRatio, 0.1);
        }
        
        // Update stability based on interaction history
        this.stability = lerp(this.stability, 
          0.5 + (this.trust * 0.5), 
          this.adaptability * 0.1
        );
        
        // Clear old interaction counts periodically
        if (frameCount % 1000 === 0) {
          this.successfulInteractions *= 0.5;
          this.failedInteractions *= 0.5;
        }
      }
    }

    function windowResized() {
      resizeCanvas(windowWidth, windowHeight);
      for (let node of nodes) {
        node.targetX = random(width);
        node.targetY = random(height);
      }
    }

    function setup() {
      createCanvas(windowWidth, windowHeight);
      startTime = millis();
      
      // Create nodes with spread out initial positions
      let nodeId = 0;
      const centerX = width / 2;
      const centerY = height / 2;
      
      for (let s = 0; s < INITIAL_CLUSTERS; s++) {
        // Position superclusters in a loose arrangement around the center
        const superAngle = (s * TWO_PI / INITIAL_CLUSTERS) + random(-0.3, 0.3);
        const superRadius = min(width, height) * random(0.3, 0.4); // Larger initial radius
        const superX = centerX + cos(superAngle) * superRadius;
        const superY = centerY + sin(superAngle) * superRadius;
        
        // Determine number of clusters for this supercluster using gaussian distribution
        const numClusters = constrain(round(gaussianRandom(MEAN_CLUSTERS, CLUSTER_STD_DEV)), MIN_CLUSTERS, MAX_CLUSTERS);
        
        for (let c = 0; c < numClusters; c++) {
          // Create spread out cluster positions
          const clusterAngle = superAngle + (c * TWO_PI / numClusters) + random(-0.4, 0.4);
          const clusterRadius = min(width, height) * random(0.15, 0.25); // Larger cluster radius
          const clusterX = superX + cos(clusterAngle) * clusterRadius;
          const clusterY = superY + sin(clusterAngle) * clusterRadius;
          
          // Create a cluster center with larger random offset
          const clusterCenterX = clusterX + random(-40, 40);
          const clusterCenterY = clusterY + random(-40, 40);
          
          for (let n = 0; n < NODES_PER_CLUSTER; n++) {
            const node = new Node(nodeId++, c, s);
            
            // Position nodes with wider distribution around cluster center
            const angle = random(TWO_PI);
            const distance = random(30, 80) * (1 + random(-0.4, 0.4));
            node.x = clusterCenterX + cos(angle) * distance;
            node.y = clusterCenterY + sin(angle) * distance;
            
            // Set initial target with wider drift
            node.targetX = node.x + random(-50, 50);
            node.targetY = node.y + random(-50, 50);
            
            // Completely randomize states and traits
            node.state = random(['active', 'dormant', 'transitioning']);
            node.traits = {
              efficiency: random(0.8, 1.2),
              adaptability: random(0.8, 1.2),
              cooperation: random(0.8, 1.2),
              aggression: random(0.8, 1.2)
            };
            
            nodes.push(node);
          }
        }
      }

      // Calculate initial population after all nodes are created
      INITIAL_POPULATION = nodes.length;
      
      // Create initial edges
      updateEdges();

      // Add mouse interaction
      document.addEventListener('mousemove', (e) => {
        mouseX = e.clientX;
        mouseY = e.clientY;
      });
    }

    function updateEdges() {
      if (frameCount % 180 !== 0) return;

      edgeMap.clear();
      const newEdges = [];
      
      updateSpatialGrid();
      
      globalInteractionTimer++;
      const isGlobalInteractionFrame = globalInteractionTimer % 5 === 0;
      
      // Reset connection counts
      for (let node of nodes) {
        node.currentConnections = 0;
      }

      // First pass: normal edge creation
      for (let node of nodes) {
        const nearbyNodes = getNearbyNodes(node, LOCAL_RADIUS, isGlobalInteractionFrame);
        
        for (let other of nearbyNodes) {
          if (node.id < other.id) {
            // Check max connections limit with more flexibility
            if (node.currentConnections >= node.maxConnections * 1.5 || 
                other.currentConnections >= other.maxConnections * 1.5) {
              continue;
            }
            
            let probability;
            let type;
            
            if (node.cluster === other.cluster && 
                node.supercluster === other.supercluster) {
              probability = BASE_INTRA_CLUSTER_DENSITY;
              type = 'intra';
            } else if (node.supercluster === other.supercluster) {
              probability = BASE_INTER_CLUSTER_DENSITY;
              type = 'inter';
            } else {
              probability = BASE_INTER_SUPER_DENSITY;
              type = 'super';
            }
            
            // Increase probability for nodes with no connections
            if (node.currentConnections === 0 || other.currentConnections === 0) {
              probability *= 2;
            }
            
            const traitSimilarity = getTraitSimilarity(node, other);
            probability *= 1 + (traitSimilarity * TRAIT_CLUSTERING_STRENGTH);
            
            if (dist(node.x, node.y, other.x, other.y) > LOCAL_RADIUS) {
              probability *= 1.5;
            }
            
            if (node.state === 'active' && other.state === 'active') {
              probability *= 1.5;
            } else if (node.state === 'dormant' || other.state === 'dormant') {
              probability *= 0.5;
            }
            
            const energyDiff = abs(node.energy - other.energy);
            probability *= map(energyDiff, 0, 1, 1.2, 0.8);
            
            const timePhase = (millis() - startTime) / currentCycleDuration * TWO_PI;
            const fastPhase = (millis() - startTime) / (currentCycleDuration / 5) * TWO_PI;
            const variation = sin(timePhase + node.supercluster * PI/2) * 0.2 +
                            sin(fastPhase + node.cluster * PI/3) * 0.1;
            
            probability += variation;
            
            if (random() < probability) {
              const edgeId = `${node.id}-${other.id}`;
              const existingEdge = edgeMap.get(edgeId);
              
              if (existingEdge) {
                existingEdge.age++;
                newEdges.push(existingEdge);
                node.currentConnections++;
                other.currentConnections++;
              } else {
                const newEdge = new Edge(node, other, type);
                edgeMap.set(edgeId, newEdge);
                newEdges.push(newEdge);
                node.currentConnections++;
                other.currentConnections++;
              }
            }
          }
        }
      }

      // Second pass: ensure isolated nodes get at least one connection
      for (let node of nodes) {
        if (node.currentConnections === 0) {
          const nearbyNodes = getNearbyNodes(node, LOCAL_RADIUS * 1.5, true);
          let bestCandidate = null;
          let bestScore = -1;

          for (let other of nearbyNodes) {
            if (other !== node) {
              const score = (1 / (1 + dist(node.x, node.y, other.x, other.y))) * 
                           (1 + getTraitSimilarity(node, other)) *
                           (other.currentConnections < other.maxConnections ? 2 : 1);
              
              if (score > bestScore) {
                bestScore = score;
                bestCandidate = other;
              }
            }
          }

          if (bestCandidate) {
            const edgeId = `${Math.min(node.id, bestCandidate.id)}-${Math.max(node.id, bestCandidate.id)}`;
            if (!edgeMap.has(edgeId)) {
              const type = node.cluster === bestCandidate.cluster ? 'intra' : 
                          node.supercluster === bestCandidate.supercluster ? 'inter' : 'super';
              const newEdge = new Edge(node, bestCandidate, type);
              edgeMap.set(edgeId, newEdge);
              newEdges.push(newEdge);
              node.currentConnections++;
              bestCandidate.currentConnections++;
            }
          }
        }
      }
      
      edges = newEdges;
    }

    function getOscillatingParameters() {
      const elapsed = (millis() - startTime);
      const mainPhase = (elapsed % currentCycleDuration) / currentCycleDuration * TWO_PI;
      const subPhase = (elapsed % currentSubcycleDuration) / currentSubcycleDuration * TWO_PI;
      
      return {
        springLength: {
          intra: map(sin(mainPhase), -1, 1, 35, 45),
          inter: map(sin(mainPhase + PI/3), -1, 1, 70, 90),
          super: map(sin(mainPhase + 2*PI/3), -1, 1, 110, 140)
        },
        springStrength: {
          intra: map(cos(subPhase), -1, 1, 0.09, 0.11),
          inter: map(cos(subPhase + PI/3), -1, 1, 0.05, 0.07),
          super: map(cos(subPhase + 2*PI/3), -1, 1, 0.025, 0.035)
        },
        repulsionStrength: map(sin(mainPhase * 2), -1, 1, 500, 600)
      };
    }

    function draw() {
      background(255);
      
      if (startupPhase > 0) {
        startupPhase = max(0, startupPhase - 0.005);
      }
      
      if (frameCount % 180 === 0) {
        updateEdges();
      }
      
      const params = getOscillatingParameters();
      
      updateForces(params);
      
      strokeWeight(1);
      for (let edge of edges) {
        if (!edge.shouldRender) continue;

        const age = millis() - edge.birth;
        const isNew = age < 1000;
        
        const edgeColor = edge.getColor();
        
        if (isNew && edge.shouldGlow) {
          strokeWeight(3);
          const glowColor = color(
            min(255, red(edgeColor) + 30),
            min(255, green(edgeColor) + 30),
            min(255, blue(edgeColor) + 40),
            60
          );
          stroke(glowColor);
          line(edge.source.x, edge.source.y, edge.target.x, edge.target.y);
          
          strokeWeight(2);
          const innerGlowColor = color(
            min(255, red(edgeColor) + 40),
            min(255, green(edgeColor) + 40),
            min(255, blue(edgeColor) + 50),
            100
          );
          stroke(innerGlowColor);
          line(edge.source.x, edge.source.y, edge.target.x, edge.target.y);
        }
        
        strokeWeight(1);
        stroke(edgeColor);
        line(edge.source.x, edge.source.y, edge.target.x, edge.target.y);
      }
      
      noStroke();
      for (let node of nodes) {
        const x = node.x;
        const y = node.y;
        
        const pixelSize = 8;
        const dominantTrait = Object.entries(node.traits)
          .reduce((a, b) => a[1] > b[1] ? a : b)[0];
        
        let cornerOffset;
        switch(dominantTrait) {
          case 'efficiency':
            cornerOffset = {x: -1, y: -1};
            break;
          case 'adaptability':
            cornerOffset = {x: 1, y: -1};
            break;
          case 'cooperation':
            cornerOffset = {x: -1, y: 1};
            break;
          case 'aggression':
            cornerOffset = {x: 1, y: 1};
            break;
        }
        
        const coloredPixelOnTop = node.energy > 0.5;
        
        const coloredX = x + (cornerOffset.x * pixelSize * 0.3);
        const coloredY = y + (cornerOffset.y * pixelSize * 0.3);
        
        if (!coloredPixelOnTop) {
          switch(node.state) {
            case 'active':
            case 'transitioning':
              fill(170, 170, 190);
              break;
            case 'dormant':
              fill(190, 170, 170);
              break;
          }
          rect(coloredX - pixelSize/2, coloredY - pixelSize/2, pixelSize, pixelSize);
        }
        
        fill(160, map(node.resources, 0, 1, 180, 200));
        rect(x - pixelSize/2, y - pixelSize/2, pixelSize, pixelSize);
        
        if (coloredPixelOnTop) {
          switch(node.state) {
            case 'active':
            case 'transitioning':
              fill(170, 170, 190);
              break;
            case 'dormant':
              fill(190, 170, 170);
              break;
          }
          rect(coloredX - pixelSize/2, coloredY - pixelSize/2, pixelSize, pixelSize);
        }
      }

      for (let node of nodes) {
        const d = dist(node.x, node.y, mouseX, mouseY);
        if (d < 100) {
          const force = map(d, 0, 100, -2, 0);
          const angle = atan2(node.y - mouseY, node.x - mouseX);
          node.vx += cos(angle) * force;
          node.vy += sin(angle) * force;
        }
      }
    }

    function updateForces(params) {
      const forceScale = 1 - (startupPhase * 0.9);
      const velocities = new Float32Array(nodes.length * 2);
      
      updateSpatialGrid();
      
      // Handle edge-based forces
      for (let edge of edges) {
        const dx = edge.target.x - edge.source.x;
        const dy = edge.target.y - edge.source.y;
        const distance = Math.sqrt(dx * dx + dy * dy);
        
        if (distance > 0) {
          const traitSimilarity = getTraitSimilarity(edge.source, edge.target);
          const similarityFactor = 1 - (traitSimilarity * TRAIT_SIMILARITY_WEIGHT);
          
          const springLength = Math.max(
            params.springLength[edge.type] * similarityFactor * 
            (1 + Math.sin(edge.source.energy * Math.PI) * 0.2),
            MIN_NODE_DISTANCE * 1.2 // Ensure connected nodes maintain minimum distance
          );
          
          const springStrength = params.springStrength[edge.type] * 
                               (1 + traitSimilarity * TRAIT_SIMILARITY_WEIGHT) * 
                               ((edge.source.state === 'active' && edge.target.state === 'active') ? 1.2 : 1) *
                               forceScale;
          
          const force = springStrength * (distance - springLength);
          const fx = (force * dx) / distance;
          const fy = (force * dy) / distance;
          
          const sourceIndex = edge.source.id * 2;
          const targetIndex = edge.target.id * 2;
          
          velocities[sourceIndex] += fx;
          velocities[sourceIndex + 1] += fy;
          velocities[targetIndex] -= fx;
          velocities[targetIndex + 1] -= fy;
          
          const energyDiff = edge.source.energy - edge.target.energy;
          edge.source.energy -= energyDiff * 0.005;
          edge.target.energy += energyDiff * 0.005;
        }
      }
      
      // Handle magnetic and spatial forces
      for (let i = 0; i < nodes.length; i++) {
        const node = nodes[i];
        const vIndex = i * 2;
        const nearbyNodes = getNearbyNodes(node, LOCAL_RADIUS, random() < 0.1);
        
        // Add gentle counter-clockwise rotation around canvas center
        const dx = node.x - width/2;
        const dy = node.y - height/2;
        const distFromCenter = Math.sqrt(dx * dx + dy * dy);
        if (distFromCenter > 0) {
          // Clockwise rotational force
          const rotationSpeed = 0.02;
          const rotationalForce = distFromCenter * rotationSpeed;
          velocities[vIndex] += (-dy / distFromCenter) * rotationalForce;
          velocities[vIndex + 1] += (dx / distFromCenter) * rotationalForce;
        }
        
        for (let other of nearbyNodes) {
          if (node !== other) {
            const dx = other.x - node.x;
            const dy = other.y - node.y;
            const distSq = dx * dx + dy * dy;
            const distance = Math.sqrt(distSq);
            
            if (distance > 0) {
              // Stronger base repulsion force with increased minimum distance
              const minDistance = MIN_NODE_DISTANCE;
              const smoothedDistance = Math.max(distance, minDistance * 0.5);
              let repulsion = params.repulsionStrength * 1.5; // Increased base repulsion
              
              // Much stronger exponential repulsion when too close
              if (distance < minDistance) {
                repulsion *= Math.exp((minDistance - distance) * 0.4); // Increased exponential factor
              }
              
              const traitSimilarity = getTraitSimilarity(node, other);
              repulsion *= (1 - traitSimilarity * TRAIT_SIMILARITY_WEIGHT);
              
              if (node.supercluster !== other.supercluster) {
                repulsion *= 1.2;
              }
              
              // Personal space force with smooth transition
              if (distance < node.personalSpace) {
                const spaceRatio = distance / node.personalSpace;
                repulsion *= map(spaceRatio, 0, 1, 4, 1, true); // Increased personal space multiplier
              }
              
              // Magnetic interaction with distance-based dampening
              if (distance < node.socialRange) {
                const socialRatio = distance / node.socialRange;
                const magneticEffect = (node.magneticPolarity * other.magneticPolarity) * 
                                    (node.magneticStrength * other.magneticStrength) *
                                    (1 - Math.pow(socialRatio, 1.5)); // Reduced power for stronger effect at medium distances
                                    
                // Limit magnetic attraction when nodes are close
                const minMagneticDistance = node.personalSpace * 0.8; // Slightly increased minimum magnetic distance
                if (distance < minMagneticDistance) {
                  const dampening = Math.pow(distance / minMagneticDistance, 1.5); // Smoother dampening
                  repulsion *= (1 - magneticEffect * 0.4 * dampening); // Increased magnetic effect
                } else {
                  repulsion *= (1 - magneticEffect * 0.4); // Increased magnetic effect
                }
              }
              
              // Add small random variation to prevent perfect alignments
              repulsion *= (1 + random(-0.05, 0.05));
              
              // Calculate force with smoothed distance
              const force = repulsion / (smoothedDistance * smoothedDistance);
              const normalizedDx = dx / distance;
              const normalizedDy = dy / distance;
              
              velocities[vIndex] -= (force * normalizedDx) * 0.7; // Slightly increased force scaling
              velocities[vIndex + 1] -= (force * normalizedDy) * 0.7;
            }
          }
        }
        
        // Random movement with personality influence and smoothing
        if (random() < 0.1) {
          const randomForce = random(0.3, 1.5) * node.magneticStrength; // Reduced range for smoother movement
          const randomAngle = random(TWO_PI);
          velocities[vIndex] += Math.cos(randomAngle) * randomForce;
          velocities[vIndex + 1] += Math.sin(randomAngle) * randomForce;
        }
      }
      
      // Adjust damping for smoother overall movement
      const damping = 0.015; // Slightly reduced for smoother motion
      const margin = 50;
      const boundaryForce = 0.05;
      
      for (let i = 0; i < nodes.length; i++) {
        const node = nodes[i];
        const vIndex = i * 2;
        
        // Apply velocity with maximum speed limit
        const speed = Math.sqrt(
          velocities[vIndex] * velocities[vIndex] + 
          velocities[vIndex + 1] * velocities[vIndex + 1]
        );
        const maxSpeed = 5;
        
        if (speed > maxSpeed) {
          const scale = maxSpeed / speed;
          velocities[vIndex] *= scale;
          velocities[vIndex + 1] *= scale;
        }
        
        node.x += velocities[vIndex] * damping;
        node.y += velocities[vIndex + 1] * damping;
        
        // Smoother boundary forces
        if (node.x < margin) {
          const boundaryDist = margin - node.x;
          velocities[vIndex] += boundaryDist * boundaryForce * (1 - Math.exp(-boundaryDist * 0.1));
        }
        if (node.x > width - margin) {
          const boundaryDist = node.x - (width - margin);
          velocities[vIndex] -= boundaryDist * boundaryForce * (1 - Math.exp(-boundaryDist * 0.1));
        }
        if (node.y < margin) {
          const boundaryDist = margin - node.y;
          velocities[vIndex + 1] += boundaryDist * boundaryForce * (1 - Math.exp(-boundaryDist * 0.1));
        }
        if (node.y > height - margin) {
          const boundaryDist = node.y - (height - margin);
          velocities[vIndex + 1] -= boundaryDist * boundaryForce * (1 - Math.exp(-boundaryDist * 0.1));
        }
      }
    }

    function updateNodeStates() {
      // Track nodes to remove and add
      const nodesToRemove = [];
      const newNodes = [];
      
      // Environmental factors
      const environmentalStress = (sin(frameCount / 1000) + 1) / 2;
      const resourceAbundance = (cos(frameCount / 1400) + 1) / 2;
      
      // Update population pressure
      updatePopulationPressure();
      
      for (let node of nodes) {
        // Age nodes
        node.age++;
        
        // Resource dynamics
        node.resources *= 0.99;
        node.resources += resourceAbundance * 0.02 * node.traits.efficiency;
        node.resources = constrain(node.resources, 0, 1);
        
        // Energy dynamics
        const environmentalDrain = environmentalStress * (2 - node.traits.adaptability) * 0.01;
        node.energy *= 0.99;
        node.energy += node.resources * 0.03 * node.traits.efficiency;
        node.energy -= environmentalDrain;
        node.energy = constrain(node.energy, 0, 1);
        
        // Resource sharing/competition with neighbors
        for (let edge of edges) {
          if (edge.source === node || edge.target === node) {
            const neighbor = edge.source === node ? edge.target : edge.source;
            const resourceDiff = node.resources - neighbor.resources;
            
            if (resourceDiff > 0 && node.traits.cooperation > 1) {
              const sharedAmount = resourceDiff * 0.1 * node.traits.cooperation;
              node.resources -= sharedAmount;
              neighbor.resources += sharedAmount;
            }
            
            if (resourceDiff < 0 && node.traits.aggression > 1) {
              const stolenAmount = -resourceDiff * 0.1 * node.traits.aggression;
              node.resources += stolenAmount;
              neighbor.resources -= stolenAmount;
            }
          }
        }
        
        // Reproduction attempt
        const offspring = node.reproduce();
        if (offspring) {
          newNodes.push(offspring);
        }
        
        // Death conditions with population pressure
        const currentPop = nodes.length;
        const target = getPopulationTarget();
        const popRatio = currentPop / target;
        
        if (node.age > node.lifespan || 
            node.energy <= 0 || 
            node.resources <= 0 ||
            (popRatio > 1 && random() < (popRatio - 1) * 0.1)) { // Additional death chance when overpopulated
          nodesToRemove.push(node);
        }
      }
      
      // Remove dead nodes
      nodes = nodes.filter(node => !nodesToRemove.includes(node));
      
      // Add new nodes
      nodes.push(...newNodes);
    }

    function clusterMaintenance() {
      // Spatial partitioning for clusters
      const clusterGrid = new Map();
      
      // Populate grid
      clusters.forEach(c => {
        const key = `${floor(c.position.x/500)}|${floor(c.position.y/500)}`;
        if (!clusterGrid.has(key)) clusterGrid.set(key, []);
        clusterGrid.get(key).push(c);
      });

      // Check neighbors in grid cells
      clusterGrid.forEach((cellClusters, key) => {
        for (let c1 of cellClusters) {
          for (let c2 of cellClusters) {
            if (c1 !== c2 && shouldMerge(c1, c2)) {
              mergeClusters(c1, c2);
            }
          }
        }
      });
    }

    function shouldMerge(c1, c2) {
      const dist = p5.Vector.dist(c1.position, c2.position);
      const traitDiff = Object.keys(c1.traits).reduce((sum, t) => 
        sum + abs(c1.traits[t] - c2.traits[t]), 0);
      
      return dist < 300 && traitDiff < 0.5;
    }

    class SuperclusterManager {
      constructor() {
        this.parent = new Map();
      }
      
      findRoot(cluster) {
        while (this.parent.get(cluster) !== cluster) {
          cluster = this.parent.get(cluster);
        }
        return cluster;
      }

      union(c1, c2) {
        const root1 = this.findRoot(c1);
        const root2 = this.findRoot(c2);
        this.parent.set(root2, root1);
      }

      getSuperclusters() {
        const groups = new Map();
        clusters.forEach(c => {
          const root = this.findRoot(c);
          if (!groups.has(root)) groups.set(root, []);
          groups.get(root).push(c);
        });
        return groups;
      }
    }

    const superclusterMetrics = {
      formationRate: 0,
      averageLifespan: 0,
      sizeDistribution: [],
      traitDivergence: 0
    };
  </script>
</body>
</html>