<!DOCTYPE html>
<html>
<head>
  <title>Hierarchical Modular Network</title>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/p5.js/1.4.0/p5.js"></script>
  <style>
    body, html {
      margin: 0;
      padding: 0;
      width: 100%;
      height: 100%;
      overflow: hidden;
    }
    canvas {
      width: 100% !important;
      height: 100% !important;
    }
  </style>
</head>
<body>
  <script>
    // Network parameters
    const NUM_SUPERCLUSTERS = 4;
    const CLUSTERS_PER_SUPERCLUSTER = 3;
    const NODES_PER_CLUSTER = 8;
    const BASE_INTRA_CLUSTER_DENSITY = 0.8;
    const BASE_INTER_CLUSTER_DENSITY = 0.2;
    const BASE_INTER_SUPER_DENSITY = 0.05;
    const TRAIT_SIMILARITY_WEIGHT = 0.3;
    const TRAIT_CLUSTERING_STRENGTH = 1.2;

    // Population cycle parameters
    const INITIAL_POPULATION = NUM_SUPERCLUSTERS * CLUSTERS_PER_SUPERCLUSTER * NODES_PER_CLUSTER;
    const POPULATION_CYCLE_DURATION = 3000;
    const GROWTH_PHASE_DURATION = 2000;
    const COLLAPSE_PHASE_DURATION = 1000;
    const MAX_POPULATION_MULTIPLIER = 1.5;
    const MIN_POPULATION_MULTIPLIER = 0.5;
    let populationCycleStartFrame = 0;
    let isInGrowthPhase = true;

    // Visual parameters
    const NODE_SIZE = 10;
    const BASE_CYCLE_DURATION = 60000;
    const BASE_SUBCYCLE_DURATION = 20000;
    let currentCycleDuration = BASE_CYCLE_DURATION;
    let currentSubcycleDuration = BASE_SUBCYCLE_DURATION;
    const CYCLE_VARIATION = 0.2;

    // Spatial partitioning parameters
    const GRID_CELL_SIZE = 150;
    const LOCAL_RADIUS = 200;
    const GLOBAL_RADIUS = 500;
    const GLOBAL_CHECK_FREQUENCY = 0.1;
    let spatialGrid = [];
    let gridWidth = 0;
    let gridHeight = 0;
    
    // Network data structures
    let nodes = [];
    let edges = [];
    let edgeMap = new Map();
    let startTime;
    let dynamicEdges = new Set();
    let startupPhase = 1.0;
    let globalInteractionTimer = 0;

    // Helper function to get grid cell indices
    function getGridIndices(x, y) {
      return {
        x: Math.floor(x / GRID_CELL_SIZE),
        y: Math.floor(y / GRID_CELL_SIZE)
      };
    }

    // Update spatial grid
    function updateSpatialGrid() {
      // Calculate grid dimensions
      gridWidth = Math.ceil(width / GRID_CELL_SIZE);
      gridHeight = Math.ceil(height / GRID_CELL_SIZE);
      
      // Reset grid with pre-allocated arrays
      spatialGrid = new Array(gridWidth);
      for (let x = 0; x < gridWidth; x++) {
        spatialGrid[x] = new Array(gridHeight);
        for (let y = 0; y < gridHeight; y++) {
          spatialGrid[x][y] = [];
        }
      }
      
      // Add nodes to grid
      for (let node of nodes) {
        const indices = getGridIndices(node.x, node.y);
        if (indices.x >= 0 && indices.x < gridWidth && 
            indices.y >= 0 && indices.y < gridHeight) {
          spatialGrid[indices.x][indices.y].push(node);
        }
      }
    }

    // Get nearby nodes using optimized grid lookup
    function getNearbyNodes(node, radius, includeGlobal = false) {
      const nearby = new Set();
      const indices = getGridIndices(node.x, node.y);
      const gridRadius = Math.ceil(radius / GRID_CELL_SIZE);
      
      // Check cells within radius
      for (let dx = -gridRadius; dx <= gridRadius; dx++) {
        for (let dy = -gridRadius; dy <= gridRadius; dy++) {
          const gx = indices.x + dx;
          const gy = indices.y + dy;
          
          if (gx >= 0 && gx < gridWidth && gy >= 0 && gy < gridHeight) {
            const cell = spatialGrid[gx][gy];
            for (let other of cell) {
              if (other !== node) {
                const dx = other.x - node.x;
                const dy = other.y - node.y;
                const distSq = dx * dx + dy * dy;
                if (distSq <= radius * radius) {
                  nearby.add(other);
                }
              }
            }
          }
        }
      }

      // Occasionally include some random global interactions
      if (includeGlobal && random() < GLOBAL_CHECK_FREQUENCY) {
        const numGlobalChecks = min(5, nodes.length - nearby.size);
        const remainingNodes = nodes.filter(n => n !== node && !nearby.has(n));
        for (let i = 0; i < numGlobalChecks; i++) {
          if (remainingNodes.length > 0) {
            const randomIndex = floor(random(remainingNodes.length));
            nearby.add(remainingNodes[randomIndex]);
            remainingNodes.splice(randomIndex, 1);
          }
        }
      }

      return nearby;
    }

    function getPopulationTarget() {
      const cycleProgress = (frameCount - populationCycleStartFrame) % POPULATION_CYCLE_DURATION;
      const isGrowth = cycleProgress < GROWTH_PHASE_DURATION;
      
      if (isGrowth !== isInGrowthPhase) {
        isInGrowthPhase = isGrowth;
        // Reset reproduction cooldowns when phase changes to allow faster adaptation
        for (let node of nodes) {
          node.lastReproduction = 0;
        }
      }

      if (isGrowth) {
        // During growth phase: smooth curve from min to max
        const growthProgress = cycleProgress / GROWTH_PHASE_DURATION;
        return INITIAL_POPULATION * lerp(MIN_POPULATION_MULTIPLIER, MAX_POPULATION_MULTIPLIER, growthProgress);
      } else {
        // During collapse phase: smooth curve from max to min
        const collapseProgress = (cycleProgress - GROWTH_PHASE_DURATION) / COLLAPSE_PHASE_DURATION;
        return INITIAL_POPULATION * lerp(MAX_POPULATION_MULTIPLIER, MIN_POPULATION_MULTIPLIER, collapseProgress);
      }
    }

    function updatePopulationPressure() {
      const target = getPopulationTarget();
      const currentPop = nodes.length;
      
      for (let node of nodes) {
        if (currentPop > target) {
          const overpopulation = (currentPop - target) / target;
          node.lifespan *= (1 - overpopulation * 0.1);
          node.reproductiveEnergy = 0.7 + overpopulation * 0.2;
          node.resources *= (1 - overpopulation * 0.01);
        } else {
          const underpopulation = (target - currentPop) / target;
          node.lifespan *= (1 + underpopulation * 0.1);
          node.reproductiveEnergy = max(0.4, 0.7 - underpopulation * 0.3);
          node.resources *= (1 + underpopulation * 0.01);
        }
      }
    }

    function getTraitSimilarity(node1, node2) {
      let similarity = 0;
      let totalTraits = 0;
      
      for (let trait in node1.traits) {
        similarity += 1 - Math.abs(node1.traits[trait] - node2.traits[trait]) / 0.4;
        totalTraits++;
      }
      
      return similarity / totalTraits;
    }

    class Node {
      constructor(id, cluster, supercluster) {
        this.id = id;
        this.cluster = cluster;
        this.supercluster = supercluster;
        this.x = 0;
        this.y = 0;
        this.vx = 0;
        this.vy = 0;
        this.targetX = random(width);
        this.targetY = random(height);
        this.energy = random(0, 1);
        this.state = random(['active', 'dormant', 'transitioning']);
        this.memory = [];
        this.age = 0;
        
        this.baseLifespan = random(500, 1500);
        this.lifespan = this.baseLifespan;
        this.reproductiveEnergy = 0.7;
        this.traits = {
          efficiency: random(0.8, 1.2),
          adaptability: random(0.8, 1.2),
          cooperation: random(0.8, 1.2),
          aggression: random(0.8, 1.2)
        };
        this.resources = random(0.3, 0.7);
        this.lastReproduction = 0;
        this.reproductiveCooldown = 200;
      }

      // Modified reproduction method
      reproduce() {
        const currentPop = nodes.length;
        const target = getPopulationTarget();
        
        // Base reproduction check
        if (this.energy < this.reproductiveEnergy || 
            frameCount - this.lastReproduction < this.reproductiveCooldown) {
          return null;
        }

        // Population pressure influence
        const popRatio = currentPop / target;
        if (random() > 1.5 - popRatio) {  // Less likely to reproduce as population grows
          return null;
        }

        // Create offspring with slightly mutated traits
        const offspring = new Node(nodes.length, this.cluster, this.supercluster);
        offspring.x = this.x + random(-20, 20);
        offspring.y = this.y + random(-20, 20);
        
        // Inherit traits with mutation
        for (let trait in this.traits) {
          offspring.traits[trait] = this.traits[trait] * random(0.9, 1.1);
        }
        
        // Split energy and resources with offspring
        this.energy *= 0.6;
        offspring.energy = this.energy;
        this.resources *= 0.6;
        offspring.resources = this.resources;
        
        this.lastReproduction = frameCount;
        return offspring;
      }
    }

    class Edge {
      constructor(source, target, type) {
        this.source = source;
        this.target = target;
        this.type = type;
        this.strength = 1;
        this.age = 0;
        this.birth = millis();
        this.shouldGlow = random() < 0.05;
        this.shouldRender = type === 'intra' || random() < 0.2;
        this.id = `${Math.min(source.id, target.id)}-${Math.max(source.id, target.id)}`;
      }

      getColor() {
        const activeColor = color(170, 170, 190, 180);
        const dormantColor = color(190, 170, 170, 180);
        
        const sourceActive = this.source.state === 'active' || this.source.state === 'transitioning';
        const targetActive = this.target.state === 'active' || this.target.state === 'transitioning';
        
        if (sourceActive && targetActive) {
          return activeColor;
        } else if (!sourceActive && !targetActive) {
          return dormantColor;
        } else {
          return color(180, 170, 180, 180);
        }
      }
    }

    function windowResized() {
      resizeCanvas(windowWidth, windowHeight);
      for (let node of nodes) {
        node.targetX = random(width);
        node.targetY = random(height);
      }
    }

    function setup() {
      createCanvas(windowWidth, windowHeight);
      startTime = millis();
      
      // Create nodes with spread out initial positions
      let nodeId = 0;
      const centerX = width / 2;
      const centerY = height / 2;
      
      for (let s = 0; s < NUM_SUPERCLUSTERS; s++) {
        // Position superclusters in a loose arrangement around the center
        const superAngle = (s * TWO_PI / NUM_SUPERCLUSTERS) + random(-0.3, 0.3);
        const superRadius = min(width, height) * random(0.3, 0.4); // Larger initial radius
        const superX = centerX + cos(superAngle) * superRadius;
        const superY = centerY + sin(superAngle) * superRadius;
        
        for (let c = 0; c < CLUSTERS_PER_SUPERCLUSTER; c++) {
          // Create spread out cluster positions
          const clusterAngle = superAngle + (c * TWO_PI / CLUSTERS_PER_SUPERCLUSTER) + random(-0.4, 0.4);
          const clusterRadius = min(width, height) * random(0.15, 0.25); // Larger cluster radius
          const clusterX = superX + cos(clusterAngle) * clusterRadius;
          const clusterY = superY + sin(clusterAngle) * clusterRadius;
          
          // Create a cluster center with larger random offset
          const clusterCenterX = clusterX + random(-40, 40);
          const clusterCenterY = clusterY + random(-40, 40);
          
          for (let n = 0; n < NODES_PER_CLUSTER; n++) {
            const node = new Node(nodeId++, c, s);
            
            // Position nodes with wider distribution around cluster center
            const angle = random(TWO_PI);
            const distance = random(30, 80) * (1 + random(-0.4, 0.4));
            node.x = clusterCenterX + cos(angle) * distance;
            node.y = clusterCenterY + sin(angle) * distance;
            
            // Set initial target with wider drift
            node.targetX = node.x + random(-50, 50);
            node.targetY = node.y + random(-50, 50);
            
            // Completely randomize states and traits
            node.state = random(['active', 'dormant', 'transitioning']);
            node.traits = {
              efficiency: random(0.8, 1.2),
              adaptability: random(0.8, 1.2),
              cooperation: random(0.8, 1.2),
              aggression: random(0.8, 1.2)
            };
            
            nodes.push(node);
          }
        }
      }
      
      // Create initial edges
      updateEdges();

      // Add mouse interaction
      document.addEventListener('mousemove', (e) => {
        mouseX = e.clientX;
        mouseY = e.clientY;
      });
    }

    function updateEdges() {
      if (frameCount % 180 !== 0) return;

      edgeMap.clear();
      const newEdges = [];
      
      updateSpatialGrid();
      
      globalInteractionTimer++;
      const isGlobalInteractionFrame = globalInteractionTimer % 5 === 0;
      
      for (let node of nodes) {
        const nearbyNodes = getNearbyNodes(node, LOCAL_RADIUS, isGlobalInteractionFrame);
        
        for (let other of nearbyNodes) {
          if (node.id < other.id) {
            let probability;
            let type;
            
            if (node.cluster === other.cluster && 
                node.supercluster === other.supercluster) {
              probability = BASE_INTRA_CLUSTER_DENSITY;
              type = 'intra';
            } else if (node.supercluster === other.supercluster) {
              probability = BASE_INTER_CLUSTER_DENSITY;
              type = 'inter';
            } else {
              probability = BASE_INTER_SUPER_DENSITY;
              type = 'super';
            }
            
            const traitSimilarity = getTraitSimilarity(node, other);
            probability *= 1 + (traitSimilarity * TRAIT_CLUSTERING_STRENGTH);
            
            if (dist(node.x, node.y, other.x, other.y) > LOCAL_RADIUS) {
              probability *= 1.5;
            }
            
            if (node.state === 'active' && other.state === 'active') {
              probability *= 1.5;
            } else if (node.state === 'dormant' || other.state === 'dormant') {
              probability *= 0.5;
            }
            
            const energyDiff = abs(node.energy - other.energy);
            probability *= map(energyDiff, 0, 1, 1.2, 0.8);
            
            const timePhase = (millis() - startTime) / currentCycleDuration * TWO_PI;
            const fastPhase = (millis() - startTime) / (currentCycleDuration / 5) * TWO_PI;
            const variation = sin(timePhase + node.supercluster * PI/2) * 0.2 +
                            sin(fastPhase + node.cluster * PI/3) * 0.1;
            
            probability += variation;
            
            if (random() < probability) {
              const edgeId = `${node.id}-${other.id}`;
              const existingEdge = edgeMap.get(edgeId);
              
              if (existingEdge) {
                existingEdge.age++;
                newEdges.push(existingEdge);
              } else {
                const newEdge = new Edge(node, other, type);
                edgeMap.set(edgeId, newEdge);
                newEdges.push(newEdge);
              }
            }
          }
        }
      }
      
      edges = newEdges;
    }

    function getOscillatingParameters() {
      const elapsed = (millis() - startTime);
      const mainPhase = (elapsed % currentCycleDuration) / currentCycleDuration * TWO_PI;
      const subPhase = (elapsed % currentSubcycleDuration) / currentSubcycleDuration * TWO_PI;
      
      return {
        springLength: {
          intra: map(sin(mainPhase), -1, 1, 35, 45),
          inter: map(sin(mainPhase + PI/3), -1, 1, 70, 90),
          super: map(sin(mainPhase + 2*PI/3), -1, 1, 110, 140)
        },
        springStrength: {
          intra: map(cos(subPhase), -1, 1, 0.09, 0.11),
          inter: map(cos(subPhase + PI/3), -1, 1, 0.05, 0.07),
          super: map(cos(subPhase + 2*PI/3), -1, 1, 0.025, 0.035)
        },
        repulsionStrength: map(sin(mainPhase * 2), -1, 1, 500, 600)
      };
    }

    function draw() {
      background(255);
      
      if (startupPhase > 0) {
        startupPhase = max(0, startupPhase - 0.005);
      }
      
      if (frameCount % 180 === 0) {
        updateEdges();
      }
      
      const params = getOscillatingParameters();
      
      updateForces(params);
      
      strokeWeight(1);
      for (let edge of edges) {
        if (!edge.shouldRender) continue;

        const age = millis() - edge.birth;
        const isNew = age < 1000;
        
        const edgeColor = edge.getColor();
        
        if (isNew && edge.shouldGlow) {
          strokeWeight(3);
          const glowColor = color(
            min(255, red(edgeColor) + 30),
            min(255, green(edgeColor) + 30),
            min(255, blue(edgeColor) + 40),
            60
          );
          stroke(glowColor);
          line(edge.source.x, edge.source.y, edge.target.x, edge.target.y);
          
          strokeWeight(2);
          const innerGlowColor = color(
            min(255, red(edgeColor) + 40),
            min(255, green(edgeColor) + 40),
            min(255, blue(edgeColor) + 50),
            100
          );
          stroke(innerGlowColor);
          line(edge.source.x, edge.source.y, edge.target.x, edge.target.y);
        }
        
        strokeWeight(1);
        stroke(edgeColor);
        line(edge.source.x, edge.source.y, edge.target.x, edge.target.y);
      }
      
      noStroke();
      for (let node of nodes) {
        const x = node.x;
        const y = node.y;
        
        const pixelSize = 8;
        const dominantTrait = Object.entries(node.traits)
          .reduce((a, b) => a[1] > b[1] ? a : b)[0];
        
        let cornerOffset;
        switch(dominantTrait) {
          case 'efficiency':
            cornerOffset = {x: -1, y: -1};
            break;
          case 'adaptability':
            cornerOffset = {x: 1, y: -1};
            break;
          case 'cooperation':
            cornerOffset = {x: -1, y: 1};
            break;
          case 'aggression':
            cornerOffset = {x: 1, y: 1};
            break;
        }
        
        const coloredPixelOnTop = node.energy > 0.5;
        
        const coloredX = x + (cornerOffset.x * pixelSize * 0.4);
        const coloredY = y + (cornerOffset.y * pixelSize * 0.4);
        
        if (!coloredPixelOnTop) {
          switch(node.state) {
            case 'active':
            case 'transitioning':
              fill(170, 170, 190);
              break;
            case 'dormant':
              fill(190, 170, 170);
              break;
          }
          rect(coloredX - pixelSize/2, coloredY - pixelSize/2, pixelSize, pixelSize);
        }
        
        fill(160, map(node.resources, 0, 1, 180, 200));
        rect(x - pixelSize/2, y - pixelSize/2, pixelSize, pixelSize);
        
        if (coloredPixelOnTop) {
          switch(node.state) {
            case 'active':
            case 'transitioning':
              fill(170, 170, 190);
              break;
            case 'dormant':
              fill(190, 170, 170);
              break;
          }
          rect(coloredX - pixelSize/2, coloredY - pixelSize/2, pixelSize, pixelSize);
        }
      }

      for (let node of nodes) {
        const d = dist(node.x, node.y, mouseX, mouseY);
        if (d < 100) {
          const force = map(d, 0, 100, -2, 0);
          const angle = atan2(node.y - mouseY, node.x - mouseX);
          node.vx += cos(angle) * force;
          node.vy += sin(angle) * force;
        }
      }
    }

    function updateForces(params) {
      const forceScale = 1 - (startupPhase * 0.9);
      const velocities = new Float32Array(nodes.length * 2);
      
      updateSpatialGrid();
      
      for (let edge of edges) {
        const dx = edge.target.x - edge.source.x;
        const dy = edge.target.y - edge.source.y;
        const distance = Math.sqrt(dx * dx + dy * dy);
        
        if (distance > 0) {
          const traitSimilarity = getTraitSimilarity(edge.source, edge.target);
          const similarityFactor = 1 - (traitSimilarity * TRAIT_SIMILARITY_WEIGHT);
          
          const springLength = params.springLength[edge.type] * 
                             similarityFactor * 
                             (1 + Math.sin(edge.source.energy * Math.PI) * 0.2);
          
          const springStrength = params.springStrength[edge.type] * 
                               (1 + traitSimilarity * TRAIT_SIMILARITY_WEIGHT) * 
                               ((edge.source.state === 'active' && edge.target.state === 'active') ? 1.2 : 1) *
                               forceScale;
          
          const force = springStrength * (distance - springLength);
          const fx = (force * dx) / distance;
          const fy = (force * dy) / distance;
          
          const sourceIndex = edge.source.id * 2;
          const targetIndex = edge.target.id * 2;
          
          velocities[sourceIndex] += fx;
          velocities[sourceIndex + 1] += fy;
          velocities[targetIndex] -= fx;
          velocities[targetIndex + 1] -= fy;
          
          const energyDiff = edge.source.energy - edge.target.energy;
          edge.source.energy -= energyDiff * 0.005;
          edge.target.energy += energyDiff * 0.005;
        }
      }
      
      for (let i = 0; i < nodes.length; i++) {
        const node = nodes[i];
        const vIndex = i * 2;
        const nearbyNodes = getNearbyNodes(node, LOCAL_RADIUS, random() < 0.1);
        
        for (let other of nearbyNodes) {
          if (node !== other) {
            const dx = other.x - node.x;
            const dy = other.y - node.y;
            const distSq = dx * dx + dy * dy;
            
            if (distSq > 0) {
              let repulsion = params.repulsionStrength;
              const traitSimilarity = getTraitSimilarity(node, other);
              repulsion *= (1 - traitSimilarity * TRAIT_SIMILARITY_WEIGHT);
              
              if (node.supercluster !== other.supercluster) {
                repulsion *= 1.2;
              }
              
              repulsion *= (1 + random(-0.1, 0.1));
              const force = repulsion / distSq;
              
              velocities[vIndex] -= (force * dx) * 0.5;
              velocities[vIndex + 1] -= (force * dy) * 0.5;
            }
          }
        }
        
        if (random() < 0.1) {
          const randomForce = random(0.5, 2);
          const randomAngle = random(TWO_PI);
          velocities[vIndex] += Math.cos(randomAngle) * randomForce;
          velocities[vIndex + 1] += Math.sin(randomAngle) * randomForce;
        }
      }
      
      const damping = 0.02;
      const margin = 50;
      const boundaryForce = 0.05;
      
      for (let i = 0; i < nodes.length; i++) {
        const node = nodes[i];
        const vIndex = i * 2;
        
        node.x += velocities[vIndex] * damping;
        node.y += velocities[vIndex + 1] * damping;
        
        if (node.x < margin) velocities[vIndex] += (margin - node.x) * boundaryForce;
        if (node.x > width - margin) velocities[vIndex] -= (node.x - (width - margin)) * boundaryForce;
        if (node.y < margin) velocities[vIndex + 1] += (margin - node.y) * boundaryForce;
        if (node.y > height - margin) velocities[vIndex + 1] -= (node.y - (height - margin)) * boundaryForce;
      }
    }

    function updateNodeStates() {
      // Track nodes to remove and add
      const nodesToRemove = [];
      const newNodes = [];
      
      // Environmental factors
      const environmentalStress = (sin(frameCount / 1000) + 1) / 2;
      const resourceAbundance = (cos(frameCount / 1400) + 1) / 2;
      
      // Update population pressure
      updatePopulationPressure();
      
      for (let node of nodes) {
        // Age nodes
        node.age++;
        
        // Resource dynamics
        node.resources *= 0.99;
        node.resources += resourceAbundance * 0.02 * node.traits.efficiency;
        node.resources = constrain(node.resources, 0, 1);
        
        // Energy dynamics
        const environmentalDrain = environmentalStress * (2 - node.traits.adaptability) * 0.01;
        node.energy *= 0.99;
        node.energy += node.resources * 0.03 * node.traits.efficiency;
        node.energy -= environmentalDrain;
        node.energy = constrain(node.energy, 0, 1);
        
        // Resource sharing/competition with neighbors
        for (let edge of edges) {
          if (edge.source === node || edge.target === node) {
            const neighbor = edge.source === node ? edge.target : edge.source;
            const resourceDiff = node.resources - neighbor.resources;
            
            if (resourceDiff > 0 && node.traits.cooperation > 1) {
              const sharedAmount = resourceDiff * 0.1 * node.traits.cooperation;
              node.resources -= sharedAmount;
              neighbor.resources += sharedAmount;
            }
            
            if (resourceDiff < 0 && node.traits.aggression > 1) {
              const stolenAmount = -resourceDiff * 0.1 * node.traits.aggression;
              node.resources += stolenAmount;
              neighbor.resources -= stolenAmount;
            }
          }
        }
        
        // Reproduction attempt
        const offspring = node.reproduce();
        if (offspring) {
          newNodes.push(offspring);
        }
        
        // Death conditions with population pressure
        const currentPop = nodes.length;
        const target = getPopulationTarget();
        const popRatio = currentPop / target;
        
        if (node.age > node.lifespan || 
            node.energy <= 0 || 
            node.resources <= 0 ||
            (popRatio > 1 && random() < (popRatio - 1) * 0.1)) { // Additional death chance when overpopulated
          nodesToRemove.push(node);
        }
      }
      
      // Remove dead nodes
      nodes = nodes.filter(node => !nodesToRemove.includes(node));
      
      // Add new nodes
      nodes.push(...newNodes);
    }
  </script>
</body>
</html>