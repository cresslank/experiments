<!DOCTYPE html>
<html>
<head>
  <title>Hierarchical Modular Network</title>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/p5.js/1.4.0/p5.js"></script>
  <style>
    body, html {
      margin: 0;
      padding: 0;
      width: 100%;
      height: 100%;
      overflow: hidden;
    }
    canvas {
      width: 100% !important;
      height: 100% !important;
    }
  </style>
</head>
<body>
  <script>
    // Network parameters
    const NUM_SUPERCLUSTERS = 4;
    const CLUSTERS_PER_SUPERCLUSTER = 3;
    const NODES_PER_CLUSTER = 8;
    const BASE_INTRA_CLUSTER_DENSITY = 0.8;
    const BASE_INTER_CLUSTER_DENSITY = 0.2;
    const BASE_INTER_SUPER_DENSITY = 0.05;
    const TRAIT_SIMILARITY_WEIGHT = 0.3; // How much trait similarity affects forces
    const TRAIT_CLUSTERING_STRENGTH = 1.2; // Multiplier for trait-based clustering

    // Population cycle parameters
    const INITIAL_POPULATION = NUM_SUPERCLUSTERS * CLUSTERS_PER_SUPERCLUSTER * NODES_PER_CLUSTER;
    const POPULATION_CYCLE_DURATION = 3000; // Frames for one complete cycle
    const GROWTH_PHASE_DURATION = 2000;     // Frames for growth phase (slower growth)
    const COLLAPSE_PHASE_DURATION = 1000;   // Frames for collapse phase (faster decline)
    const MAX_POPULATION_MULTIPLIER = 1.5;  // Peak at 150% of initial population
    const MIN_POPULATION_MULTIPLIER = 0.5;  // Bottom at 50% of initial population
    let populationCycleStartFrame = 0;      // Track when the current cycle started
    let isInGrowthPhase = true;            // Track which phase we're in

    // Visual parameters
    const NODE_SIZE = 10;
    const BASE_CYCLE_DURATION = 60000;
    const BASE_SUBCYCLE_DURATION = 20000;
    let currentCycleDuration = BASE_CYCLE_DURATION;
    let currentSubcycleDuration = BASE_SUBCYCLE_DURATION;
    const CYCLE_VARIATION = 0.2;

    // Spatial partitioning parameters
    const GRID_CELL_SIZE = 150; // Increased for larger interaction radius
    const LOCAL_RADIUS = 200; // Radius for frequent local interactions
    const GLOBAL_RADIUS = 500; // Radius for occasional global interactions
    const GLOBAL_CHECK_FREQUENCY = 0.1; // Probability of checking global interactions
    let spatialGrid = {}; // Grid cells containing nodes
    
    // Network data structures
    let nodes = [];
    let edges = [];
    let startTime;
    let dynamicEdges = new Set();
    let startupPhase = 1.0;
    let globalInteractionTimer = 0; // Timer for periodic global interactions

    // Helper function to get grid cell key
    function getGridKey(x, y) {
      const gridX = Math.floor(x / GRID_CELL_SIZE);
      const gridY = Math.floor(y / GRID_CELL_SIZE);
      return `${gridX},${gridY}`;
    }

    // Update spatial grid
    function updateSpatialGrid() {
      spatialGrid = {};
      for (let node of nodes) {
        const key = getGridKey(node.x, node.y);
        if (!spatialGrid[key]) {
          spatialGrid[key] = [];
        }
        spatialGrid[key].push(node);
      }
    }

    // Get nearby nodes using grid with dynamic radius
    function getNearbyNodes(node, radius, includeGlobal = false) {
      const nearby = new Set();
      const gridRadius = Math.ceil(radius / GRID_CELL_SIZE);
      const baseX = Math.floor(node.x / GRID_CELL_SIZE);
      const baseY = Math.floor(node.y / GRID_CELL_SIZE);

      // Always check local radius
      for (let dx = -gridRadius; dx <= gridRadius; dx++) {
        for (let dy = -gridRadius; dy <= gridRadius; dy++) {
          const key = `${baseX + dx},${baseY + dy}`;
          if (spatialGrid[key]) {
            for (let other of spatialGrid[key]) {
              if (other !== node) {
                const dx = other.x - node.x;
                const dy = other.y - node.y;
                const distSq = dx * dx + dy * dy;
                if (distSq <= radius * radius) {
                  nearby.add(other);
                }
              }
            }
          }
        }
      }

      // Occasionally include some random global interactions
      if (includeGlobal && random() < GLOBAL_CHECK_FREQUENCY) {
        const numGlobalChecks = min(5, nodes.length - nearby.size);
        const remainingNodes = nodes.filter(n => n !== node && !nearby.has(n));
        for (let i = 0; i < numGlobalChecks; i++) {
          if (remainingNodes.length > 0) {
            const randomIndex = floor(random(remainingNodes.length));
            nearby.add(remainingNodes[randomIndex]);
            remainingNodes.splice(randomIndex, 1);
          }
        }
      }

      return nearby;
    }

    function getPopulationTarget() {
      const cycleProgress = (frameCount - populationCycleStartFrame) % POPULATION_CYCLE_DURATION;
      const isGrowth = cycleProgress < GROWTH_PHASE_DURATION;
      
      if (isGrowth !== isInGrowthPhase) {
        isInGrowthPhase = isGrowth;
        // Reset reproduction cooldowns when phase changes to allow faster adaptation
        for (let node of nodes) {
          node.lastReproduction = 0;
        }
      }

      if (isGrowth) {
        // During growth phase: smooth curve from min to max
        const growthProgress = cycleProgress / GROWTH_PHASE_DURATION;
        return INITIAL_POPULATION * lerp(MIN_POPULATION_MULTIPLIER, MAX_POPULATION_MULTIPLIER, growthProgress);
      } else {
        // During collapse phase: smooth curve from max to min
        const collapseProgress = (cycleProgress - GROWTH_PHASE_DURATION) / COLLAPSE_PHASE_DURATION;
        return INITIAL_POPULATION * lerp(MAX_POPULATION_MULTIPLIER, MIN_POPULATION_MULTIPLIER, collapseProgress);
      }
    }

    function updatePopulationPressure() {
      const target = getPopulationTarget();
      const currentPop = nodes.length;
      
      // Adjust reproduction and death rates based on population pressure
      for (let node of nodes) {
        if (currentPop > target) {
          // Increase death probability and reduce reproduction when over target
          const overpopulation = (currentPop - target) / target;
          node.lifespan *= (1 - overpopulation * 0.1);  // Shorter lifespan
          node.reproductiveEnergy = 0.7 + overpopulation * 0.2;  // Harder to reproduce
          node.resources *= (1 - overpopulation * 0.01);  // Faster resource depletion
        } else {
          // Decrease death probability and increase reproduction when under target
          const underpopulation = (target - currentPop) / target;
          node.lifespan *= (1 + underpopulation * 0.1);  // Longer lifespan
          node.reproductiveEnergy = max(0.4, 0.7 - underpopulation * 0.3);  // Easier to reproduce
          node.resources *= (1 + underpopulation * 0.01);  // Slower resource depletion
        }
      }
    }

    function getTraitSimilarity(node1, node2) {
      let similarity = 0;
      let totalTraits = 0;
      
      for (let trait in node1.traits) {
        similarity += 1 - Math.abs(node1.traits[trait] - node2.traits[trait]) / 0.4; // 0.4 is max trait difference
        totalTraits++;
      }
      
      return similarity / totalTraits; // Returns value between 0 and 1
    }

    class Node {
      constructor(id, cluster, supercluster) {
        this.id = id;
        this.cluster = cluster;
        this.supercluster = supercluster;
        this.x = 0;
        this.y = 0;
        this.vx = 0;
        this.vy = 0;
        this.targetX = random(width);
        this.targetY = random(height);
        this.energy = random(0, 1);
        this.state = random(['active', 'dormant', 'transitioning']);
        this.memory = [];
        this.age = 0;
        
        // Modified properties for population dynamics
        this.baseLifespan = random(500, 1500);
        this.lifespan = this.baseLifespan;
        this.reproductiveEnergy = 0.7;
        this.traits = {
          efficiency: random(0.8, 1.2),
          adaptability: random(0.8, 1.2),
          cooperation: random(0.8, 1.2),
          aggression: random(0.8, 1.2)
        };
        this.resources = random(0.3, 0.7);
        this.lastReproduction = 0;
        this.reproductiveCooldown = 200;
      }

      // Modified reproduction method
      reproduce() {
        const currentPop = nodes.length;
        const target = getPopulationTarget();
        
        // Base reproduction check
        if (this.energy < this.reproductiveEnergy || 
            frameCount - this.lastReproduction < this.reproductiveCooldown) {
          return null;
        }

        // Population pressure influence
        const popRatio = currentPop / target;
        if (random() > 1.5 - popRatio) {  // Less likely to reproduce as population grows
          return null;
        }

        // Create offspring with slightly mutated traits
        const offspring = new Node(nodes.length, this.cluster, this.supercluster);
        offspring.x = this.x + random(-20, 20);
        offspring.y = this.y + random(-20, 20);
        
        // Inherit traits with mutation
        for (let trait in this.traits) {
          offspring.traits[trait] = this.traits[trait] * random(0.9, 1.1);
        }
        
        // Split energy and resources with offspring
        this.energy *= 0.6;
        offspring.energy = this.energy;
        this.resources *= 0.6;
        offspring.resources = this.resources;
        
        this.lastReproduction = frameCount;
        return offspring;
      }
    }

    class Edge {
      constructor(source, target, type) {
        this.source = source;
        this.target = target;
        this.type = type; // 'intra', 'inter', or 'super'
        this.strength = 1;
        this.age = 0; // Track how long the edge has existed
        this.birth = millis(); // When the edge was created
        this.shouldGlow = random() < 0.05; // Only 5% of edges will show glow effect
        this.shouldRender = type === 'intra' || random() < 0.2; // Only render 20% of non-intra edges
      }

      getColor() {
        // Define base colors for different node states with 70% opacity
        const activeColor = color(50, 50, 255, 180);   // Blue for active (was 255)
        const dormantColor = color(255, 50, 50, 180);  // Red for dormant (was 255)
        
        // Get states of connected nodes
        const sourceActive = this.source.state === 'active' || this.source.state === 'transitioning';
        const targetActive = this.target.state === 'active' || this.target.state === 'transitioning';
        
        if (sourceActive && targetActive) {
          return activeColor;  // Both active = blue
        } else if (!sourceActive && !targetActive) {
          return dormantColor; // Both dormant = red
        } else {
          // Mixed states = purple (blend of red and blue) with 70% opacity
          return color(152, 50, 152, 180);
        }
      }
    }

    function windowResized() {
      resizeCanvas(windowWidth, windowHeight);
      for (let node of nodes) {
        node.targetX = random(width);
        node.targetY = random(height);
      }
    }

    function setup() {
      createCanvas(windowWidth, windowHeight);
      startTime = millis();
      
      // Create nodes with hierarchical clustering and organized initial positions
      let nodeId = 0;
      const centerX = width / 2;
      const centerY = height / 2;
      
      for (let s = 0; s < NUM_SUPERCLUSTERS; s++) {
        // Position superclusters in a circle around the center
        const superAngle = (s * TWO_PI / NUM_SUPERCLUSTERS);
        const superRadius = min(width, height) * 0.3; // Supercluster radius from center
        const superX = centerX + cos(superAngle) * superRadius;
        const superY = centerY + sin(superAngle) * superRadius;
        
        for (let c = 0; c < CLUSTERS_PER_SUPERCLUSTER; c++) {
          // Position clusters in smaller circles within their supercluster
          const clusterAngle = superAngle + (c * TWO_PI / CLUSTERS_PER_SUPERCLUSTER) * 0.5;
          const clusterRadius = min(width, height) * 0.15; // Cluster radius from supercluster center
          const clusterX = superX + cos(clusterAngle) * clusterRadius;
          const clusterY = superY + sin(clusterAngle) * clusterRadius;
          
          for (let n = 0; n < NODES_PER_CLUSTER; n++) {
            // Position nodes in small circles within their cluster
            const nodeAngle = clusterAngle + (n * TWO_PI / NODES_PER_CLUSTER) * 0.5;
            const nodeRadius = min(width, height) * 0.05; // Node radius from cluster center
            const node = new Node(nodeId++, c, s);
            node.x = clusterX + cos(nodeAngle) * nodeRadius;
            node.y = clusterY + sin(nodeAngle) * nodeRadius;
            node.targetX = node.x; // Set initial target to current position
            node.targetY = node.y;
            nodes.push(node);
          }
        }
      }
      
      // Create initial edges
      updateEdges();

      // Add mouse interaction
      document.addEventListener('mousemove', (e) => {
        mouseX = e.clientX;
        mouseY = e.clientY;
      });
    }

    function updateEdges() {
      // Update edges less frequently
      if (frameCount % 180 !== 0) return;

      // Randomly adjust cycle durations within bounds
      currentCycleDuration = BASE_CYCLE_DURATION * (1 + (random(-CYCLE_VARIATION, CYCLE_VARIATION)));
      currentSubcycleDuration = BASE_SUBCYCLE_DURATION * (1 + (random(-CYCLE_VARIATION, CYCLE_VARIATION)));
      
      const newEdges = [];
      
      // Update spatial grid for proximity checks
      updateSpatialGrid();
      
      // Increment global interaction timer
      globalInteractionTimer++;
      const isGlobalInteractionFrame = globalInteractionTimer % 5 === 0;
      
      // Check edges between nodes
      for (let node of nodes) {
        const nearbyNodes = getNearbyNodes(node, LOCAL_RADIUS, isGlobalInteractionFrame);
        
        for (let other of nearbyNodes) {
          if (node.id < other.id) {
            let probability;
            let type;
            
            if (node.cluster === other.cluster && 
                node.supercluster === other.supercluster) {
              probability = BASE_INTRA_CLUSTER_DENSITY;
              type = 'intra';
            } else if (node.supercluster === other.supercluster) {
              probability = BASE_INTER_CLUSTER_DENSITY;
              type = 'inter';
            } else {
              probability = BASE_INTER_SUPER_DENSITY;
              type = 'super';
            }
            
            // Boost probability based on trait similarity
            const traitSimilarity = getTraitSimilarity(node, other);
            probability *= 1 + (traitSimilarity * TRAIT_CLUSTERING_STRENGTH);
            
            // Boost probability for global interactions
            if (dist(node.x, node.y, other.x, other.y) > LOCAL_RADIUS) {
              probability *= 1.5;
            }
            
            // State-based probability adjustments
            if (node.state === 'active' && other.state === 'active') {
              probability *= 1.5;
            } else if (node.state === 'dormant' || other.state === 'dormant') {
              probability *= 0.5;
            }
            
            const energyDiff = abs(node.energy - other.energy);
            probability *= map(energyDiff, 0, 1, 1.2, 0.8);
            
            const timePhase = (millis() - startTime) / currentCycleDuration * TWO_PI;
            const fastPhase = (millis() - startTime) / (currentCycleDuration / 5) * TWO_PI;
            const variation = sin(timePhase + node.supercluster * PI/2) * 0.2 +
                            sin(fastPhase + node.cluster * PI/3) * 0.1;
            
            probability += variation;
            
            if (random() < probability) {
              const edgeKey = `${node.id}-${other.id}`;
              const existingEdge = edges.find(e => `${e.source.id}-${e.target.id}` === edgeKey);
              
              if (existingEdge) {
                existingEdge.age++;
                newEdges.push(existingEdge);
              } else {
                newEdges.push(new Edge(node, other, type));
              }
            }
          }
        }
      }
      
      edges = newEdges;
    }

    function getOscillatingParameters() {
      const elapsed = (millis() - startTime);
      const mainPhase = (elapsed % currentCycleDuration) / currentCycleDuration * TWO_PI;
      const subPhase = (elapsed % currentSubcycleDuration) / currentSubcycleDuration * TWO_PI;
      
      return {
        springLength: {
          intra: map(sin(mainPhase), -1, 1, 35, 45),
          inter: map(sin(mainPhase + PI/3), -1, 1, 70, 90),
          super: map(sin(mainPhase + 2*PI/3), -1, 1, 110, 140)
        },
        springStrength: {
          intra: map(cos(subPhase), -1, 1, 0.09, 0.11),
          inter: map(cos(subPhase + PI/3), -1, 1, 0.05, 0.07),
          super: map(cos(subPhase + 2*PI/3), -1, 1, 0.025, 0.035)
        },
        repulsionStrength: map(sin(mainPhase * 2), -1, 1, 500, 600)
      };
    }

    function draw() {
      background(255);
      
      // Update startup phase
      if (startupPhase > 0) {
        startupPhase = max(0, startupPhase - 0.005);
      }
      
      // Periodically update edge structure
      if (frameCount % 180 === 0) {
        updateEdges();
      }
      
      // Get current parameters based on oscillation
      const params = getOscillatingParameters();
      
      // Apply forces and update positions with startup phase scaling
      updateForces(params);
      
      // Draw edges with effects
      strokeWeight(1);
      for (let edge of edges) {
        // Skip rendering if this is a non-intra edge that wasn't selected for rendering
        if (!edge.shouldRender) continue;

        // Draw normal edge with potential glow for new edges
        const age = millis() - edge.birth;
        const isNew = age < 1000; // Glow for 1 second
        
        // Get edge color based on connected nodes' states
        const edgeColor = edge.getColor();
        
        if (isNew && edge.shouldGlow) {
          // Draw glow using the edge color but with lower opacity
          strokeWeight(3);
          const glowColor = color(red(edgeColor), green(edgeColor), blue(edgeColor), 35); // Was 50
          stroke(glowColor);
          line(edge.source.x, edge.source.y, edge.target.x, edge.target.y);
          
          // Draw stronger inner glow
          strokeWeight(2);
          const innerGlowColor = color(red(edgeColor), green(edgeColor), blue(edgeColor), 70); // Was 100
          stroke(innerGlowColor);
          line(edge.source.x, edge.source.y, edge.target.x, edge.target.y);
        }
        
        // Draw base edge
        strokeWeight(1);
        stroke(edgeColor);
        line(edge.source.x, edge.source.y, edge.target.x, edge.target.y);
      }
      
      // Draw nodes with dynamic colors
      noStroke();
      for (let node of nodes) {
        const x = node.x;
        const y = node.y;
        
        const pixelSize = 8; // Size for both pixels
        const dominantTrait = Object.entries(node.traits)
          .reduce((a, b) => a[1] > b[1] ? a : b)[0];
        
        // Determine corner position based on dominant trait
        let cornerOffset;
        switch(dominantTrait) {
          case 'efficiency':
            cornerOffset = {x: -1, y: -1}; // Top-left
            break;
          case 'adaptability':
            cornerOffset = {x: 1, y: -1}; // Top-right
            break;
          case 'cooperation':
            cornerOffset = {x: -1, y: 1}; // Bottom-left
            break;
          case 'aggression':
            cornerOffset = {x: 1, y: 1}; // Bottom-right
            break;
        }
        
        // Determine if colored pixel should be above or below based on energy
        const coloredPixelOnTop = node.energy > 0.5;
        
        // Calculate positions
        const coloredX = x + (cornerOffset.x * pixelSize * 0.4); // More overlap (was 0.7)
        const coloredY = y + (cornerOffset.y * pixelSize * 0.4);
        
        // Draw pixels in correct order based on layering
        if (!coloredPixelOnTop) {
          // Draw colored pixel first (will be partially covered)
          switch(node.state) {
            case 'active':
            case 'transitioning':
              fill(50, 50, 255); // Bright blue
              break;
            case 'dormant':
              fill(255, 50, 50); // Bright red
              break;
          }
          rect(coloredX - pixelSize/2, coloredY - pixelSize/2, pixelSize, pixelSize);
        }
        
        // Draw black center pixel
        fill(0, map(node.resources, 0, 1, 180, 255));
        rect(x - pixelSize/2, y - pixelSize/2, pixelSize, pixelSize);
        
        if (coloredPixelOnTop) {
          // Draw colored pixel last (will overlap black)
          switch(node.state) {
            case 'active':
            case 'transitioning':
              fill(50, 50, 255); // Bright blue
              break;
            case 'dormant':
              fill(255, 50, 50); // Bright red
              break;
          }
          rect(coloredX - pixelSize/2, coloredY - pixelSize/2, pixelSize, pixelSize);
        }
      }

      // Mouse interaction
      for (let node of nodes) {
        const d = dist(node.x, node.y, mouseX, mouseY);
        if (d < 100) {
          const force = map(d, 0, 100, -2, 0);
          const angle = atan2(node.y - mouseY, node.x - mouseX);
          node.vx += cos(angle) * force;
          node.vy += sin(angle) * force;
        }
      }
    }

    function updateForces(params) {
      // Reset velocities
      for (let node of nodes) {
        node.vx = 0;
        node.vy = 0;
      }
      
      // Update spatial grid
      updateSpatialGrid();
      
      const forceScale = 1 - (startupPhase * 0.9);
      
      // Apply spring forces with energy transfer
      for (let edge of edges) {
        let dx = edge.target.x - edge.source.x;
        let dy = edge.target.y - edge.source.y;
        let distance = sqrt(dx * dx + dy * dy);
        
        if (distance > 0) {
          // Adjust spring length based on trait similarity
          const traitSimilarity = getTraitSimilarity(edge.source, edge.target);
          const similarityFactor = 1 - (traitSimilarity * TRAIT_SIMILARITY_WEIGHT);
          
          const springLength = params.springLength[edge.type] * 
                             similarityFactor * // Similar traits = shorter preferred distance
                             (1 + sin(edge.source.energy * PI) * 0.2);
          
          const springStrength = params.springStrength[edge.type] * 
                               (1 + traitSimilarity * TRAIT_SIMILARITY_WEIGHT) * // Similar traits = stronger attraction
                               ((edge.source.state === 'active' && edge.target.state === 'active') ? 1.2 : 1) *
                               forceScale;
          
          let force = springStrength * (distance - springLength);
          
          // Energy transfer along edges
          const energyDiff = edge.source.energy - edge.target.energy;
          edge.source.energy -= energyDiff * 0.005;
          edge.target.energy += energyDiff * 0.005;
          
          // Apply forces
          let fx = (force * dx) / distance;
          let fy = (force * dy) / distance;
          
          edge.source.vx += fx;
          edge.source.vy += fy;
          edge.target.vx -= fx;
          edge.target.vy -= fy;
        }
      }
      
      // Apply repulsion with trait-based modifications
      for (let node of nodes) {
        const nearbyNodes = getNearbyNodes(node, LOCAL_RADIUS, random() < 0.1);
        
        for (let other of nearbyNodes) {
          if (node !== other) {
            let dx = other.x - node.x;
            let dy = other.y - node.y;
            let distSq = dx * dx + dy * dy;
            
            if (distSq > 0) {
              let repulsion = params.repulsionStrength;
              
              // Modify repulsion based on trait similarity
              const traitSimilarity = getTraitSimilarity(node, other);
              repulsion *= (1 - traitSimilarity * TRAIT_SIMILARITY_WEIGHT); // Similar traits = less repulsion
              
              if (node.supercluster !== other.supercluster) {
                repulsion *= 1.2;
              }
              
              // Add slight random variation to repulsion
              repulsion *= (1 + random(-0.1, 0.1));
              
              let force = repulsion / distSq;
              let fx = (force * dx);
              let fy = (force * dy);
              
              node.vx -= fx * 0.5;
              node.vy -= fy * 0.5;
            }
          }
        }
      }
      
      // Add slight random movement to prevent stagnation
      for (let node of nodes) {
        if (random() < 0.1) {
          const randomForce = random(0.5, 2);
          const randomAngle = random(TWO_PI);
          node.vx += cos(randomAngle) * randomForce;
          node.vy += sin(randomAngle) * randomForce;
        }
      }
      
      // Update positions with velocity damping
      const damping = 0.02;
      for (let node of nodes) {
        node.x += node.vx * damping;
        node.y += node.vy * damping;
        
        // Keep nodes within canvas bounds with smoother boundary forces
        const margin = 50;
        const boundaryForce = 0.05;
        if (node.x < margin) node.vx += (margin - node.x) * boundaryForce;
        if (node.x > width - margin) node.vx -= (node.x - (width - margin)) * boundaryForce;
        if (node.y < margin) node.vy += (margin - node.y) * boundaryForce;
        if (node.y > height - margin) node.vy -= (node.y - (height - margin)) * boundaryForce;
      }
    }

    function updateNodeStates() {
      // Track nodes to remove and add
      const nodesToRemove = [];
      const newNodes = [];
      
      // Environmental factors
      const environmentalStress = (sin(frameCount / 1000) + 1) / 2;
      const resourceAbundance = (cos(frameCount / 1400) + 1) / 2;
      
      // Update population pressure
      updatePopulationPressure();
      
      for (let node of nodes) {
        // Age nodes
        node.age++;
        
        // Resource dynamics
        node.resources *= 0.99;
        node.resources += resourceAbundance * 0.02 * node.traits.efficiency;
        node.resources = constrain(node.resources, 0, 1);
        
        // Energy dynamics
        const environmentalDrain = environmentalStress * (2 - node.traits.adaptability) * 0.01;
        node.energy *= 0.99;
        node.energy += node.resources * 0.03 * node.traits.efficiency;
        node.energy -= environmentalDrain;
        node.energy = constrain(node.energy, 0, 1);
        
        // Resource sharing/competition with neighbors
        for (let edge of edges) {
          if (edge.source === node || edge.target === node) {
            const neighbor = edge.source === node ? edge.target : edge.source;
            const resourceDiff = node.resources - neighbor.resources;
            
            if (resourceDiff > 0 && node.traits.cooperation > 1) {
              const sharedAmount = resourceDiff * 0.1 * node.traits.cooperation;
              node.resources -= sharedAmount;
              neighbor.resources += sharedAmount;
            }
            
            if (resourceDiff < 0 && node.traits.aggression > 1) {
              const stolenAmount = -resourceDiff * 0.1 * node.traits.aggression;
              node.resources += stolenAmount;
              neighbor.resources -= stolenAmount;
            }
          }
        }
        
        // Reproduction attempt
        const offspring = node.reproduce();
        if (offspring) {
          newNodes.push(offspring);
        }
        
        // Death conditions with population pressure
        const currentPop = nodes.length;
        const target = getPopulationTarget();
        const popRatio = currentPop / target;
        
        if (node.age > node.lifespan || 
            node.energy <= 0 || 
            node.resources <= 0 ||
            (popRatio > 1 && random() < (popRatio - 1) * 0.1)) { // Additional death chance when overpopulated
          nodesToRemove.push(node);
        }
      }
      
      // Remove dead nodes
      nodes = nodes.filter(node => !nodesToRemove.includes(node));
      
      // Add new nodes
      nodes.push(...newNodes);
    }
  </script>
</body>
</html>